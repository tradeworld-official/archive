import { Project, Tag } from '../types';

// Mock Data Initializer
const INITIAL_TAGS: Tag[] = [
  { id: '1', name: 'Branding', category: 'type' },
  { id: '2', name: 'Web Design', category: 'type' },
  { id: '3', name: 'Packaging', category: 'type' },
  { id: '4', name: 'Fashion', category: 'industry' },
  { id: '5', name: 'Tech', category: 'industry' },
  { id: '6', name: 'Architecture', category: 'industry' },
];

const INITIAL_PROJECTS: Project[] = [
  {
    id: '1',
    title: 'Aether Studios',
    client: 'Aether Inc',
    date: '2024-03',
    description: 'A comprehensive rebranding for a high-end architectural visualization firm. We focused on ethereal light patterns and strict typographic hierarchies to convey precision and imagination.',
    tags: ['1', '2', '6'],
    imageUrl: 'https://picsum.photos/id/12/800/1000',
    gallery: ['https://picsum.photos/id/13/800/600', 'https://picsum.photos/id/14/800/600', 'https://picsum.photos/id/15/800/1000', 'https://picsum.photos/id/16/800/800'],
    featured: true,
  },
  {
    id: '2',
    title: 'Mono Coffee',
    client: 'Mono Roastery',
    date: '2023-11',
    description: 'Packaging design for a boutique coffee roaster based in Tokyo. The concept revolves around the daily ritual of brewing, utilizing negative space to represent pause and reflection.',
    tags: ['3', '1', '4'],
    imageUrl: 'https://picsum.photos/id/24/800/1000',
    gallery: ['https://picsum.photos/id/25/800/600', 'https://picsum.photos/id/26/800/600'],
    featured: true,
  },
  {
    id: '3',
    title: 'Nexus Interface',
    client: 'Nexus AI',
    date: '2024-01',
    description: 'UI/UX design for a generative AI platform. The interface is designed to be invisible, allowing the content generated by the user to take center stage.',
    tags: ['2', '5'],
    imageUrl: 'https://picsum.photos/id/42/800/1000',
    gallery: ['https://picsum.photos/id/43/800/600', 'https://picsum.photos/id/45/800/600'],
    featured: false,
  },
   {
    id: '4',
    title: 'Velvet Magazine',
    client: 'CondÃ© Nast',
    date: '2023-09',
    description: 'Digital editorial layout for a fashion forward publication. Focusing on typography as image.',
    tags: ['2', '4'],
    imageUrl: 'https://picsum.photos/id/64/800/1000',
    gallery: ['https://picsum.photos/id/65/800/600', 'https://picsum.photos/id/66/800/1200'],
    featured: false,
  },
];

const STORAGE_KEYS = {
  PROJECTS: 'mono_projects',
  TAGS: 'mono_tags',
  AUTH: 'mono_auth',
};

// Simulate network delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export const mockSupabase = {
  auth: {
    signIn: async (password: string) => {
      await delay(500);
      if (password === 'design123') { // Simple hardcoded password
        localStorage.setItem(STORAGE_KEYS.AUTH, 'true');
        return { user: { id: 'admin', email: 'admin@studiomono.com' }, error: null };
      }
      return { user: null, error: 'Invalid password' };
    },
    signOut: async () => {
      localStorage.removeItem(STORAGE_KEYS.AUTH);
    },
    getSession: () => {
      return localStorage.getItem(STORAGE_KEYS.AUTH) === 'true';
    }
  },
  
  data: {
    getTags: async (): Promise<Tag[]> => {
      await delay(200);
      const stored = localStorage.getItem(STORAGE_KEYS.TAGS);
      if (!stored) {
        localStorage.setItem(STORAGE_KEYS.TAGS, JSON.stringify(INITIAL_TAGS));
        return INITIAL_TAGS;
      }
      return JSON.parse(stored);
    },

    saveTag: async (tag: Tag) => {
      await delay(300);
      const stored = await mockSupabase.data.getTags();
      const existingIndex = stored.findIndex(t => t.id === tag.id);
      let newTags;
      if (existingIndex >= 0) {
        newTags = [...stored];
        newTags[existingIndex] = tag;
      } else {
        newTags = [...stored, tag];
      }
      localStorage.setItem(STORAGE_KEYS.TAGS, JSON.stringify(newTags));
      return tag;
    },
    
    deleteTag: async (id: string) => {
        await delay(300);
        const stored = await mockSupabase.data.getTags();
        const newTags = stored.filter(t => t.id !== id);
        localStorage.setItem(STORAGE_KEYS.TAGS, JSON.stringify(newTags));
    },

    getProjects: async (): Promise<Project[]> => {
      await delay(300);
      const stored = localStorage.getItem(STORAGE_KEYS.PROJECTS);
      if (!stored) {
        localStorage.setItem(STORAGE_KEYS.PROJECTS, JSON.stringify(INITIAL_PROJECTS));
        return INITIAL_PROJECTS;
      }
      return JSON.parse(stored);
    },

    getProjectById: async (id: string): Promise<Project | undefined> => {
      const projects = await mockSupabase.data.getProjects();
      return projects.find(p => p.id === id);
    },

    saveProject: async (project: Project) => {
      await delay(400);
      const stored = await mockSupabase.data.getProjects();
      const existingIndex = stored.findIndex(p => p.id === project.id);
      let newProjects;
      if (existingIndex >= 0) {
        newProjects = [...stored];
        newProjects[existingIndex] = project;
      } else {
        newProjects = [...stored, project];
      }
      localStorage.setItem(STORAGE_KEYS.PROJECTS, JSON.stringify(newProjects));
      return project;
    },

    deleteProject: async (id: string) => {
      await delay(300);
      const stored = await mockSupabase.data.getProjects();
      const newProjects = stored.filter(p => p.id !== id);
      localStorage.setItem(STORAGE_KEYS.PROJECTS, JSON.stringify(newProjects));
    }
  }
};